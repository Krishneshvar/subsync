{"version":3,"file":"typeschema.modern.mjs","sources":["../src/typeschema.ts"],"sourcesContent":["import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport type { ValidationIssue } from '@typeschema/core';\nimport { validate } from '@typeschema/main';\nimport { FieldError, FieldErrors, appendErrors } from 'react-hook-form';\nimport type { Resolver } from './types';\n\nconst parseErrorSchema = (\n  typeschemaErrors: ValidationIssue[],\n  validateAllFieldCriteria: boolean,\n): FieldErrors => {\n  const errors: Record<string, FieldError> = {};\n\n  for (; typeschemaErrors.length; ) {\n    const error = typeschemaErrors[0];\n\n    if (!error.path) {\n      continue;\n    }\n    const _path = error.path.join('.');\n\n    if (!errors[_path]) {\n      errors[_path] = { message: error.message, type: '' };\n    }\n\n    if (validateAllFieldCriteria) {\n      const types = errors[_path].types;\n      const messages = types && types[''];\n\n      errors[_path] = appendErrors(\n        _path,\n        validateAllFieldCriteria,\n        errors,\n        '',\n        messages\n          ? ([] as string[]).concat(messages as string[], error.message)\n          : error.message,\n      ) as FieldError;\n    }\n\n    typeschemaErrors.shift();\n  }\n\n  return errors;\n};\n\n/**\n * Creates a resolver for react-hook-form using TypeSchema validation\n * @param {any} schema - The TypeSchema to validate against\n * @param {any} _ - Unused parameter\n * @param {Object} resolverOptions - Additional resolver configuration\n * @param {string} [resolverOptions.mode='async'] - Validation mode\n * @returns {Resolver} A resolver function compatible with react-hook-form\n * @example\n * const schema = z.object({\n *   name: z.string().required(),\n *   age: z.number().required(),\n * });\n *\n * useForm({\n *   resolver: typeschemaResolver(schema)\n * });\n */\nexport const typeschemaResolver: Resolver =\n  (schema, _, resolverOptions = {}) =>\n  async (values, _, options) => {\n    const result = await validate(schema, values);\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    if (result.success) {\n      return {\n        errors: {} as FieldErrors,\n        values: resolverOptions.raw\n          ? Object.assign({}, values)\n          : (result.data as any),\n      };\n    }\n\n    return {\n      values: {},\n      errors: toNestErrors(\n        parseErrorSchema(\n          result.issues,\n          !options.shouldUseNativeValidation && options.criteriaMode === 'all',\n        ),\n        options,\n      ),\n    };\n  };\n"],"names":["parseErrorSchema","typeschemaErrors","validateAllFieldCriteria","errors","length","error","path","_path","join","message","type","types","messages","appendErrors","concat","shift","typeschemaResolver","schema","_","resolverOptions","async","values","options","result","validate","shouldUseNativeValidation","validateFieldsNatively","success","raw","Object","assign","data","toNestErrors","issues","criteriaMode"],"mappings":"0KAMA,MAAMA,EAAmBA,CACvBC,EACAC,KAEA,MAAMC,EAAqC,CAAE,EAE7C,KAAOF,EAAiBG,QAAU,CAChC,MAAMC,EAAQJ,EAAiB,GAE/B,IAAKI,EAAMC,KACT,SAEF,MAAMC,EAAQF,EAAMC,KAAKE,KAAK,KAM9B,GAJKL,EAAOI,KACVJ,EAAOI,GAAS,CAAEE,QAASJ,EAAMI,QAASC,KAAM,KAG9CR,EAA0B,CAC5B,MAAMS,EAAQR,EAAOI,GAAOI,MACtBC,EAAWD,GAASA,EAAM,IAEhCR,EAAOI,GAASM,EACdN,EACAL,EACAC,EACA,GACAS,EACK,GAAgBE,OAAOF,EAAsBP,EAAMI,SACpDJ,EAAMI,QAEd,CAEAR,EAAiBc,OACnB,CAEA,OAAOZ,GAoBIa,EACXA,CAACC,EAAQC,EAAGC,EAAkB,CAAA,IAC9BC,MAAOC,EAAQH,EAAGI,KAChB,MAAMC,QAAeC,EAASP,EAAQI,GAItC,OAFAC,EAAQG,2BAA6BC,EAAuB,CAAA,EAAIJ,GAE5DC,EAAOI,QACF,CACLxB,OAAQ,CAAA,EACRkB,OAAQF,EAAgBS,IACpBC,OAAOC,OAAO,CAAA,EAAIT,GACjBE,EAAOQ,MAIT,CACLV,OAAQ,CAAE,EACVlB,OAAQ6B,EACNhC,EACEuB,EAAOU,QACNX,EAAQG,2BAAsD,QAAzBH,EAAQY,cAEhDZ"}
{"version":3,"file":"valibot.modern.mjs","sources":["../src/valibot.ts"],"sourcesContent":["import { toNestErrors } from '@hookform/resolvers';\nimport {\n  FieldError,\n  FieldValues,\n  Resolver,\n  appendErrors,\n} from 'react-hook-form';\nimport { getDotPath, safeParseAsync } from 'valibot';\nimport {\n  BaseSchema,\n  BaseSchemaAsync,\n  Config,\n  InferIssue,\n  InferOutput,\n} from 'valibot';\n\n/**\n * Creates a resolver for react-hook-form using Valibot schema validation\n * @param {BaseSchema<TFieldValues, TFieldValues, any> | BaseSchemaAsync<TFieldValues, TFieldValues, any>} schema - The Valibot schema to validate against\n * @param {Partial<Omit<Config<InferIssue<typeof schema>>, 'abortPipeEarly' | 'skipPipe'>>} [schemaOptions] - Optional Valibot validation options\n * @param {Object} resolverOptions - Additional resolver configuration\n * @param {('sync' | 'async')} [resolverOptions.mode] - Validation mode\n * @param {boolean} [resolverOptions.raw] - If true, returns raw values rather than validated results\n * @returns {Resolver<InferOutput<typeof schema>>} A resolver function compatible with react-hook-form\n * @example\n * const schema = valibot.object({\n *   name: valibot.string().minLength(2),\n *   age: valibot.number().min(18)\n * });\n *\n * useForm({\n *   resolver: valibotResolver(schema)\n * });\n */\nexport function valibotResolver<TFieldValues extends FieldValues>(\n  schema:\n    | BaseSchema<TFieldValues, TFieldValues, any>\n    | BaseSchemaAsync<TFieldValues, TFieldValues, any>,\n  schemaOptions?: Partial<\n    Omit<Config<InferIssue<typeof schema>>, 'abortPipeEarly' | 'skipPipe'>\n  >,\n  resolverOptions: {\n    /**\n     * @default async\n     */\n    mode?: 'sync' | 'async';\n    /**\n     * Return the raw input values rather than the parsed values.\n     * @default false\n     */\n    raw?: boolean;\n  } = {},\n): Resolver<InferOutput<typeof schema>> {\n  return async (values, _, options) => {\n    // Check if we should validate all field criteria\n    const validateAllFieldCriteria =\n      !options.shouldUseNativeValidation && options.criteriaMode === 'all';\n\n    // Parse values with Valibot schema\n    const result = await safeParseAsync(\n      schema,\n      values,\n      Object.assign({}, schemaOptions, {\n        abortPipeEarly: !validateAllFieldCriteria,\n      }),\n    );\n\n    // If there are issues, return them as errors\n    if (result.issues) {\n      // Create errors object\n      const errors: Record<string, FieldError> = {};\n\n      // Iterate over issues to add them to errors object\n      for (; result.issues.length; ) {\n        const issue = result.issues[0];\n        // Create dot path from issue\n        const path = getDotPath(issue);\n\n        if (path) {\n          // Add first error of path to errors object\n          if (!errors[path]) {\n            errors[path] = { message: issue.message, type: issue.type };\n          }\n\n          // If configured, add all errors of path to errors object\n          if (validateAllFieldCriteria) {\n            const types = errors[path].types;\n            const messages = types && types[issue.type];\n            errors[path] = appendErrors(\n              path,\n              validateAllFieldCriteria,\n              errors,\n              issue.type,\n              messages\n                ? ([] as string[]).concat(\n                    messages as string | string[],\n                    issue.message,\n                  )\n                : issue.message,\n            ) as FieldError;\n          }\n        }\n\n        result.issues.shift();\n      }\n\n      // Return resolver result with errors\n      return {\n        values: {},\n        errors: toNestErrors(errors, options),\n      } as const;\n    }\n\n    // Otherwise, return resolver result with values\n    return {\n      values: resolverOptions.raw\n        ? Object.assign({}, values)\n        : (result.output as FieldValues),\n      errors: {},\n    };\n  };\n}\n"],"names":["valibotResolver","schema","schemaOptions","resolverOptions","values","_","options","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","result","safeParseAsync","Object","assign","abortPipeEarly","issues","errors","length","issue","path","getDotPath","message","type","types","messages","appendErrors","concat","shift","toNestErrors","raw","output"],"mappings":"2JAkCgB,SAAAA,EACdC,EAGAC,EAGAC,EAUI,CAAA,GAEJ,OAAcC,MAAAA,EAAQC,EAAGC,KAEvB,MAAMC,GACHD,EAAQE,2BAAsD,QAAzBF,EAAQG,aAG1CC,QAAeC,EACnBV,EACAG,EACAQ,OAAOC,OAAO,CAAE,EAAEX,EAAe,CAC/BY,gBAAiBP,KAKrB,GAAIG,EAAOK,OAAQ,CAEjB,MAAMC,EAAqC,CAAA,EAG3C,KAAON,EAAOK,OAAOE,QAAU,CAC7B,MAAMC,EAAQR,EAAOK,OAAO,GAEtBI,EAAOC,EAAWF,GAExB,GAAIC,IAEGH,EAAOG,KACVH,EAAOG,GAAQ,CAAEE,QAASH,EAAMG,QAASC,KAAMJ,EAAMI,OAInDf,GAA0B,CAC5B,MAAMgB,EAAQP,EAAOG,GAAMI,MACrBC,EAAWD,GAASA,EAAML,EAAMI,MACtCN,EAAOG,GAAQM,EACbN,EACAZ,EACAS,EACAE,EAAMI,KACNE,EACK,GAAgBE,OACfF,EACAN,EAAMG,SAERH,EAAMG,QAEd,CAGFX,EAAOK,OAAOY,OAChB,CAGA,MAAO,CACLvB,OAAQ,CAAE,EACVY,OAAQY,EAAaZ,EAAQV,GAEjC,CAGA,MAAO,CACLF,OAAQD,EAAgB0B,IACpBjB,OAAOC,OAAO,CAAA,EAAIT,GACjBM,EAAOoB,OACZd,OAAQ,IAGd"}
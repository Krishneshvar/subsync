{"version":3,"file":"io-ts.module.js","sources":["../src/arrayToPath.ts","../src/errorsToRecord.ts","../src/io-ts.ts"],"sourcesContent":["import * as Either from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\n\nconst arrayToPath = (paths: Either.Either<string, number>[]): string =>\n  paths.reduce(\n    (previous, path, index) =>\n      pipe(\n        path,\n        Either.fold(\n          (key) => `${index > 0 ? '.' : ''}${key}`,\n          (key) => `[${key}]`,\n        ),\n        (path) => `${previous}${path}`,\n      ),\n    '',\n  );\n\nexport default arrayToPath;\n","import * as Either from 'fp-ts/Either';\nimport * as Option from 'fp-ts/Option';\nimport * as ReadonlyArray from 'fp-ts/ReadonlyArray';\nimport * as ReadonlyRecord from 'fp-ts/ReadonlyRecord';\nimport * as SemiGroup from 'fp-ts/Semigroup';\nimport { absurd, flow, identity, not, pipe } from 'fp-ts/function';\nimport * as t from 'io-ts';\nimport {\n  ExactType,\n  IntersectionType,\n  RefinementType,\n  TaggedUnionType,\n  UnionType,\n  ValidationError,\n} from 'io-ts';\nimport { FieldError } from 'react-hook-form';\nimport arrayToPath from './arrayToPath';\n\nexport type ErrorObject = Record<string, FieldError>;\nexport type FieldErrorWithPath = FieldError & { path: string };\n\nconst INSTANCE_TYPES_TO_FILTER = [\n  TaggedUnionType,\n  UnionType,\n  IntersectionType,\n  ExactType,\n  RefinementType,\n];\nconst formatErrorPath = (context: t.Context): string =>\n  pipe(\n    context,\n    ReadonlyArray.filterMapWithIndex((index, contextEntry) => {\n      const previousIndex = index - 1;\n      const previousContextEntry =\n        previousIndex === -1 ? undefined : context[previousIndex];\n      const shouldBeFiltered =\n        previousContextEntry === undefined ||\n        INSTANCE_TYPES_TO_FILTER.some(\n          (type) => previousContextEntry.type instanceof type,\n        );\n\n      return shouldBeFiltered ? Option.none : Option.some(contextEntry);\n    }),\n    ReadonlyArray.map(({ key }) => key),\n    ReadonlyArray.map((key) =>\n      pipe(\n        key,\n        (k) => parseInt(k, 10),\n        Either.fromPredicate(not<number>(Number.isNaN), () => key),\n      ),\n    ),\n    ReadonlyArray.toArray,\n    arrayToPath,\n  );\n\nconst formatError = (e: t.ValidationError): FieldErrorWithPath => {\n  const path = formatErrorPath(e.context);\n\n  const message = pipe(\n    e.message,\n    Either.fromNullable(e.context),\n    Either.mapLeft(\n      flow(\n        ReadonlyArray.last,\n        Option.map(\n          (contextEntry) =>\n            `expected ${contextEntry.type.name} but got ${JSON.stringify(\n              contextEntry.actual,\n            )}`,\n        ),\n        Option.getOrElseW(() =>\n          absurd<string>('Error context is missing name' as never),\n        ),\n      ),\n    ),\n    Either.getOrElseW(identity),\n  );\n\n  const type = pipe(\n    e.context,\n    ReadonlyArray.last,\n    Option.map((contextEntry) => contextEntry.type.name),\n    Option.getOrElse(() => 'unknown'),\n  );\n\n  return { message, type, path };\n};\n\n// this is almost the same function like Semigroup.getObjectSemigroup but reversed\n// in order to get the first error\nconst getObjectSemigroup = <\n  A extends Record<string, unknown> = never,\n>(): SemiGroup.Semigroup<A> => ({\n  concat: (first, second) => Object.assign({}, second, first),\n});\n\nconst concatToSingleError = (\n  errors: ReadonlyArray<FieldErrorWithPath>,\n): ErrorObject =>\n  pipe(\n    errors,\n    ReadonlyArray.map((error) => ({\n      [error.path]: {\n        type: error.type,\n        message: error.message,\n      },\n    })),\n    (errors) => SemiGroup.fold(getObjectSemigroup<ErrorObject>())({}, errors),\n  );\n\nconst appendSeveralErrors: SemiGroup.Semigroup<FieldErrorWithPath> = {\n  concat: (a, b) => ({\n    ...b,\n    types: { ...a.types, [a.type]: a.message, [b.type]: b.message },\n  }),\n};\n\nconst concatToMultipleErrors = (\n  errors: ReadonlyArray<FieldErrorWithPath>,\n): ErrorObject =>\n  pipe(\n    ReadonlyRecord.fromFoldableMap(appendSeveralErrors, ReadonlyArray.Foldable)(\n      errors,\n      (error) => [error.path, error],\n    ),\n    ReadonlyRecord.map((errorWithPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { path, ...error } = errorWithPath;\n\n      return error;\n    }),\n  );\n\nconst errorsToRecord =\n  (validateAllFieldCriteria: boolean) =>\n  (validationErrors: ReadonlyArray<ValidationError>): ErrorObject => {\n    const concat = validateAllFieldCriteria\n      ? concatToMultipleErrors\n      : concatToSingleError;\n\n    return pipe(validationErrors, ReadonlyArray.map(formatError), concat);\n  };\n\nexport default errorsToRecord;\n","import { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport * as Either from 'fp-ts/Either';\nimport { pipe } from 'fp-ts/function';\nimport * as t from 'io-ts';\nimport { FieldValues, Resolver } from 'react-hook-form';\nimport errorsToRecord from './errorsToRecord';\n\n/**\n * Creates a resolver for react-hook-form using io-ts schema validation\n * @param {t.Type<TFieldValues, T>} schema - The io-ts schema to validate against\n * @param {Object} options - Additional resolver configuration\n * @param {string} [options.mode='async'] - Validation mode\n * @returns {Resolver<t.OutputOf<typeof schema>>} A resolver function compatible with react-hook-form\n * @example\n * const schema = t.type({\n *   name: t.string,\n *   age: t.number\n * });\n *\n * useForm({\n *   resolver: ioTsResolver(schema)\n * });\n */\nexport function ioTsResolver<\n  T extends Record<string, any>,\n  TFieldValues extends FieldValues,\n>(schema: t.Type<TFieldValues, T>): Resolver<t.OutputOf<typeof schema>> {\n  return (values, _context, options) =>\n    pipe(\n      values,\n      schema.decode,\n      Either.mapLeft(\n        errorsToRecord(\n          !options.shouldUseNativeValidation && options.criteriaMode === 'all',\n        ),\n      ),\n      Either.mapLeft((errors) => toNestErrors(errors, options)),\n      Either.fold(\n        (errors) => ({\n          values: {},\n          errors,\n        }),\n        (values) => {\n          options.shouldUseNativeValidation &&\n            validateFieldsNatively({}, options);\n\n          return {\n            values,\n            errors: {},\n          };\n        },\n      ),\n    );\n}\n"],"names":["arrayToPath","paths","reduce","previous","path","index","pipe","Either","fold","key","_excluded","INSTANCE_TYPES_TO_FILTER","TaggedUnionType","UnionType","IntersectionType","ExactType","RefinementType","formatError","e","context","ReadonlyArray","filterMapWithIndex","contextEntry","previousIndex","previousContextEntry","undefined","some","type","Option","none","map","_ref","k","parseInt","fromPredicate","not","Number","isNaN","toArray","message","fromNullable","mapLeft","flow","last","name","JSON","stringify","actual","getOrElseW","absurd","identity","getOrElse","concatToSingleError","errors","error","_ref2","SemiGroup","concat","first","second","Object","assign","appendSeveralErrors","a","b","_extends2","_extends","types","concatToMultipleErrors","ReadonlyRecord","fromFoldableMap","Foldable","errorWithPath","_objectWithoutPropertiesLoose","ioTsResolver","schema","values","_context","options","decode","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","validationErrors","toNestErrors","validateFieldsNatively"],"mappings":"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"}